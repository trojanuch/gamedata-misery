----------------------------------------------------------
--	lead_containers.script
--  Original scripting done by the NARODNAYA SOLYANKA team
--  Modified for use in Misery 2.0+ by Yastiandrie
----------------------------------------------------------
local cfg_containers = {}
local inv_containers = {}

local lost_cont_id = -1
local menu_showed = false
local ui


function on_game_start()
	callback_register("actor_on_update",on_actor_update)
	callback_register("actor_on_item_drop",actor_on_item_drop)
	callback_register("actor_on_item_take",actor_on_item_take)
end


function actor_on_item_drop(obj)
	local obj_id = obj:id()
	local obj_sect = obj:section()
	local obj_clsid = obj:clsid()
  
	if obj_sect=="lead_box_open" or obj_sect == "lead_box_closed" or obj_sect == "lead_box_half" then
		on_lose_container(obj_id)
	end
end


function actor_on_item_take(obj)
	local obj_id = obj:id()
	local obj_sect = obj:section()
	local obj_clsid = obj:clsid()
	
	if obj_sect == "lead_box_open" or obj_sect == "lead_box_closed" or obj_sect == "lead_box_half" then
		
		-- Yasti: Loading Table Data From actor storage--
		if empty(inv_containers) then
			inv_containers = load_table("inv_containers")
--			alun_utils.printf("lead_containers.actor_on_item_take: loading inv_containers table")
		end
		if empty(cfg_containers) then
			cfg_containers = load_table("cfg_containers")
--			alun_utils.printf("lead_containers.actor_on_item_take: loading cfg_containers table")
		end
		
--		alun_utils.printf("lead_containers.actor_on_item_take: lead box found..registering. ID= "..tostring(obj_id))
		register_container(obj_id, obj_sect)
	end
end


----------------------------------------------------------
--Update function removes a lead box from inventory table if it is dropped. Also unregisters artifacts and adjusts ballast
----------------------------------------------------------  

function on_actor_update()
	if lost_cont_id > 0 then
		local n = get_inv_index(lost_cont_id)
		if alife():object(lost_cont_id) ~= nil then
			local arts = inv_containers[n].arts
			local ini = system_ini()
			local inv_rad
			local art_section
			local belt_rad
			
			for i = 1, table.getn(arts) do
				if arts[i] ~=0 then
				inventory_radiation.register_artefact(arts[i], -1, true)
				end
			end
		end
		
		xr_effects.disable_ui_inventory(db.actor, nil)
		lead_ballast.check_ballast()
		xr_effects.enable_ui(db.actor, nil)
		inv_containers[n].inv = nil
		save_table("inv_containers", inv_containers)
		save_table("cfg_containers", cfg_containers)
		
		lost_cont_id = -1
	end
end

----------------------------------------------------------
--Function registers containers to an indexed table, Skips over containers already registered and currently in inventory
----------------------------------------------------------  
function register_container(cont_id, cont_section, cont_arts)
	if get_inv_index(cont_id)>0 and inv_containers[get_inv_index(cont_id)].inv == true then  -- Already registered
--		alun_utils.printf("lead_containers.register_container: container already registered")
		return true
	end
	
	local f = get_cfg_index(cont_section)
    local ini = system_ini()
	
	if f==0 then
		if ini:section_exist(cont_section) then
			local tmp = {}
			tmp.section = cont_section
			if ini:line_exist(cont_section, "container_slots") then
				tmp.slots = ini:r_u32(cont_section, "container_slots")
			else
				return false
			end

			tmp.tx = ini:r_u32(cont_section, "inv_grid_x")
			tmp.ty = ini:r_u32(cont_section, "inv_grid_y")
			tmp.weight = ini:r_float(cont_section, "inv_weight")
			table.insert(cfg_containers, tmp)
			f = table.getn(cfg_containers)

		else
			return false
		end
	end
	
	local cnt = {}
	cnt.id = cont_id
	cnt.type = f
	cnt.arts = {}
	cnt.inv = true
	local arts = cont_arts
	
	if not arts then
		arts = get_container_arts(cont_id)
	end
	
	local s = cfg_containers[f].slots
	local a
	local inv_rad
    local art_section
    local belt_rad
	
	for i = 1, s do
		if (not arts) or (not arts[i]) or (arts[i]=="_") then
			cnt.arts[i] = 0
		else
			a = inventory_radiation.register_artefact(arts[i],1,true)
			cnt.arts[i] = a
		end
	end
	
	xr_effects.disable_ui_inventory(db.actor, nil)
	lead_ballast.check_ballast()
	xr_effects.enable_ui(db.actor, nil)
	table.insert(inv_containers, cnt)

	if arts and (table.getn(arts)>s) then  --Yasti: If container has more artifacts listed in it then slots
		alun_utils.printf("lead_containers.register_container: Artifacts than the number of slots in the container #"..cont_id..". When opening the container unnecessary artifacts will be removed.")
	end
--	alun_utils.printf("lead_containers.register_container: Container Registered= "..tostring(cont_section))
	return true
end


----------------------------------------------------------  
--Function used to update container after using the UI
----------------------------------------------------------  

function respawn_container(cont_index)
	local ic = inv_containers[cont_index]
	
	if not ic then
--    	return false
	end
	
	local a = {}
	
	for i=1, cfg_containers[ic.type].slots do
		if ic.arts[i] then
			a[i] = ic.arts[i]
		else
			a[i] = 0
		end
	--	alun_utils.printf("lead_containers.respawn_container: arts in slots= "..tostring(a[i]))
	end
	
	--Yasti: Ensuring Proper Container Type is Spawned Depending on Number of Artifacts
	if a[1] ~= 0 and a[2] == 0 or a[1] == 0 and a[2] ~= 0 then
		cfg_containers[ic.type].section = "lead_box_half"
	elseif a[1] ~= 0 or a[2] ~= 0 then
		cfg_containers[ic.type].section = "lead_box_closed"
	else	
		cfg_containers[ic.type].section = "lead_box_open"
	end
	
	local sobj = give_item(cfg_containers[ic.type].section)
	
	if not sobj then
		return false
	else
		inv_containers[cont_index].id = sobj.id
		inv_containers[cont_index].inv = true
		save_table("inv_containers", inv_containers)
		save_table("cfg_containers", cfg_containers)
		inv_containers[cont_index].arts = a
	end
	
	menu_showed = false
end


function on_lose_container(cont_id)
	if not menu_showed then
--		alun_utils.printf("lead_containers.on_lose_container: container lost")
    if lost_cont_id > 0 then
--		alun_utils.printf("lead_containers.on_lose_container: Lost more than one container!")
    end
 
	lost_cont_id = cont_id
	end
end


----------------------------------------------------------  
--Utility Functions
----------------------------------------------------------  	
	
function get_cfg_containers_number()
  return table.getn(cfg_containers)
end


function get_inv_containers_number()
  return table.getn(inv_containers)
end


function get_cfg_index(cont_section)
  for i = 1, get_cfg_containers_number() do
    if compare_part(cont_section,cfg_containers[i].section) then
      return i
    end
  end
  return 0
end


function get_inv_index(cont_id)
  for i = 1, get_inv_containers_number() do
    if inv_containers[i].id == cont_id then
      return i
    end
  end
  return 0
end


function get_inv_container_arts(cont_index)
  return inv_containers[cont_index].arts
end


function get_container_arts(cont_id)
	local sobj = alife():object(cont_id)
	if sobj==nil then
		return nil
	end
	
	local arts = {}
	local ic = inv_containers[get_inv_index(cont_id)]
	
	if not ic then
		return
	end
	
	for i=1, cfg_containers[ic.type].slots do
		table.insert(arts, ic.arts[i])
--		alun_utils.printf("lead_containers.get_container_arts: arts in slots= "..tostring(ic.arts[i]))
	end
	
	return arts
end


function remove_container(cont_index)
  remove_obj(inv_containers[cont_index].id)
end


function set_menu_showed(f)
  menu_showed = f
end


function compare_part(a, b)
  local l = math.min(string.len(a),string.len(b))
  if string.sub(a, 1, l) == string.sub(b, 1, l) then
    return true
  end
  return false
end


function give_item(item_section)
  local a = db.actor
  return alife():create(item_section, a:position(), a:level_vertex_id(), a:game_vertex_id(), a:id())
end


function remove_obj(obj_id)
  alife():release(alife():object(obj_id), true)
end

----------------------------------------------------------
--Functions Used to Save container Tables to PSTOR
----------------------------------------------------------  

local pack_type_num=1
local pack_type_string=2
local pack_type_bool=3
local pack_type_table=4
local pack_val_endtable=5


function save_variable(variable_name, value)
	xr_logic.pstor_store(db.actor, variable_name, value)
end


function load_variable(variable_name, value_if_not_found)
	return xr_logic.pstor_retrieve(db.actor, variable_name, value_if_not_found)
end


function save_table(name,tbl)
	save_variable(name,pack_array_to_string(tbl))
end


function pack_array_to_string(array)
	return string.char(1)..pack_new(array)
end


function load_table(name)
	local var=load_variable(name)
	return (var==nil and {}) or unpack_array_from_string(var)
end


function unpack_array_from_string(str)
	if str==nil or str=="" then return {} end
  
	if string.sub(str,1,1)~=string.char(1) then
    -- Old packaging format
		return _parse(str)
	else
    -- new packaging format tagging symbol c code 1.
		return parse_new(string.sub(str,2,-1))
	end
end


function _parse(str)
	local ret={}
	local i1,i2,key
	while str and str~="" do
		i1,i2,key=string.find(str,'(.-)=>')
		if i2 then str=string.sub(str,i2+1) end
		
		i1,i2,val=string.find(str,'"(.-)"|')
		if val and i1 and i1==1 then
		-- line
			_assign(ret,key,val)
		else
			i1,i2,val=string.find(str,'(%b{})|')
			if val and i1 and i1==1 then
			-- Table
				_assign(ret,key,_parse(string.sub(val,2,-2)))
			else
				i1,i2,val=string.find(str,'(.-)|')
				if val then
				-- number or boolean
					if val=="true" then
						_assign(ret,key,true)
					elseif val=="false" then
						_assign(ret,key,false)
					else
						_assign(ret,key,val+0)
					end
				end
			end
		end
    
	if i2 then str=string.sub(str,i2+1) end
	
	end
	return ret
end

function parse_new(str,idx)
	local ret={}
	idx=idx or 1
	local key,value
	while true do
		if idx>string.len(str) then
			return ret,idx
		end
		vtype,idx=get_byte(str,idx)
		
		if vtype==pack_type_num then
			key,idx=get_num(str,idx)
		
		elseif vtype==pack_type_string then
			key,idx=get_string(str,idx)
		
		elseif vtype==pack_val_endtable then
			return ret,idx
    
		else
			return ret,idx
		end
		
		vtype,idx=get_byte(str,idx)
		
		if vtype==pack_type_num then
			value,idx=get_num(str,idx)
    
		elseif vtype==pack_type_string then
			value,idx=get_string(str,idx)
    
		elseif vtype==pack_type_bool then
			value,idx=get_bool(str,idx)
    
		elseif vtype==pack_type_table then
			value,idx=parse_new(str,idx)
		
		else
            return ret,idx
		end
    
		ret[key]=value
	end
end


function pack_new(tbl)
	local ret=""
	for k,v in pairs(tbl) do
		if type(k)=="number" then
			ret=ret..string.char(pack_type_num)..k
    
		elseif type(k)=="string" then
			ret=ret..string.char(pack_type_string)..k
    
		else
			alun_utils.printf("pack new: unsupported key type ["..tostring(type(k)).."]")
		end
		
		if type(v)=="number" then
			ret=ret..string.char(pack_type_num)..v
    
		elseif type(v)=="string" then
			ret=ret..string.char(pack_type_string)..v
    
		elseif type(v)=="boolean" then
			if v then
				ret=ret..string.char(pack_type_bool).."1"
			
			else
				ret=ret..string.char(pack_type_bool).."0"
			end
    
		elseif type(v)=="table" then
			ret=ret..string.char(pack_type_table)..pack_new(v)..string.char(pack_val_endtable)
		end
	end
	return ret
end


function get_byte(str,idx)
	return string.byte(string.sub(str,idx,idx)),idx+1
end


function get_string(str,idx)
	local idx1=string.len(str)+1
	
	for i=idx,string.len(str),1 do
		if string.byte(string.sub(str,i,i))<32 then
			idx1=i
			break
		end
	end
	
	return string.sub(str,idx,idx1-1),idx1
end


function get_num(str,idx)
	local st,idx1=get_string(str,idx)
	return st+0,idx1
end


function get_bool(str,idx)
	local st,idx1=get_string(str,idx)
	return st=="1",idx1
end


function _assign(tbl,key,val)
	local key0=string.match(key,'"(.*)"')

	if key0 then
		tbl[key0]=val
  
	else
		tbl[key+0]=val
	end
end